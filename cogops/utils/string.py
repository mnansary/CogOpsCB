import re
from fuzzywuzzy import process, fuzz
from typing import List, Optional

# --- The Normalization Helper ---
def normalize_text(s: str) -> str:
    """
    A helper function to clean up strings for better comparison.
    It removes all whitespace characters, which effectively handles extra spaces,
    tabs, newlines, and different unicode space characters.
    """
    if not isinstance(s, str):
        return ""
    # \s+ matches one or more whitespace characters of any kind
    return re.sub(r'\s+', '', s)

# --- The Main Function ---
def refine_category(
    category_from_llm: str, 
    category_list: List[str],
    score_cutoff: int = 85
) -> Optional[str]:
    """
    Finds the closest matching category from a predefined list for a given category string.

    This function addresses potential issues like extra spaces, minor typos, or
    slight rephrasing from an LLM by using fuzzy string matching.

    Args:
        category_from_llm (str): The category string generated by the language model.
        category_list (List[str]): The canonical list of valid category names.
        score_cutoff (int): The minimum similarity score (0-100) required to consider
                              a string a valid match. Defaults to 85.

    Returns:
        Optional[str]: The best matching category string from the list if the score is
                       above the cutoff, otherwise None.
    """
    if not category_from_llm or not category_from_llm.strip():
        return None

    # The `process.extractOne` function is the core of this solution.
    # It finds the best match for `category_from_llm` from the `choices` in `category_list`.
    #
    # We use a custom processor to normalize both the input and the choices before comparing,
    # which makes the matching much more robust against whitespace issues.
    
    best_match = process.extractOne(
        query=category_from_llm,
        choices=category_list,
        processor=normalize_text,  # Apply our cleaning function
        scorer=fuzz.ratio,         # Use a simple and fast similarity scorer
        score_cutoff=score_cutoff  # Don't return matches below this score
    )

    # extractOne returns a tuple (choice, score) or None if no match is found above the cutoff
    if best_match:
        return best_match[0]  # Return only the category name (the first element)
    
    return None